1.执行bash命令的4中方式：
    1.  bash 2.sh 会在当前父进程中产生生子进程，脚本执行完毕后，子进程会回到父进程中，不会影响当前环境(子shell)
    2.  ./2.sh 1和2效果相同
    3.  source 2.sh 会在当前父进程中执行，不会产生子进程，会影响当前环境(当前shell)
    4.  . 2.sh 3和4效果相同
2.export 修饰的变量在当前shell和子shell是生效的，在另一个操作窗口是不生效的

3.环境变量的分类：环境变量env | more,预定义变量set | more,位置变量（给shell变量赋值$1,$2,,,,${10},${11}）
--环境变量：
$PATH环境变量是，是命令搜索路径，使用了export修改，所以是对当前shell和当前子shell是生效的
$PS1环境变量，是当前提示的终端[\u@\h \W]\$
--预定义变量：
$?:上一条命令是否正确执行,是否有错误，正确返回0，错误返回非0；条件判断也会使用
$$:当前进程的PID
$0:当前进程的名称
--位置变量：
$1,$2,,,,${10},${11}
技巧：${2}_:表示如果${2}传入的是空值，则取_，如果${2}有值，则会多出一个_；中括号不能省略，所以使用${2-_}

4.环境变量配置文件：
etc下为所有用户通用的配置文件，~家目录下的配置文件，是保存用户特有的配置
logging shell（su - 用户名，一下所有目录都会执行） 和 no logging shell（su 用户名，会执行/etc/bashrc和~/.bashrc）
文件：/etc/profile
目录：/etc/profile.d/
文件：~/.bash_profile
文件：~/.bashrc
文件：/etc/bashrc
su - root配置文件的执行顺序(登录时，建议使用该方法)：/etc/profile
                         ~/.bash-profile
                         ~/.bashrc
                         /etc/bashrc

su root配置文件的执行顺序：~/.bashrc
                       /etc/bashrc
注意：配置文件修改后不会立即生效，需要source /etc/bashrc才会生效
===========================================================
数组：
IPTS=(10.0.0.1 10.0.0.2 10.0.0.3)
显示所有的元素
echo ${IPTS[@]}
线束数组元素个数
echo $[#IPTS[@]]
显示数组的第一个元素
echo ${IPTS[0]}
============================================================
一：转义符号\
特殊字符：
#注释：被注释的内容不会被执行
;分号：连接多个命令
\转义字符：\n \r \t \$ \" \\
二.引用符号：
"",不完全引用,会对变量进行转义
'',完全引用,将变量原样输出
``,
============================================================
预算符：
赋值运算符：=，可进行算数赋值和字符串赋值
算术运算符：expr 4 + 5，支持+，-，*，/，**平方，%取余，expr支持整数
数字常量：let "变量名=变量值" 等价于 (( a = 10)) 双圆括号的简化
例子：(( a++ ))
例子：echo $(( 10 + 20 ))
============================================================
特殊符号大全：
引号：""不完全引用，''完全引用，``执行命令
括号：(),(()),$() 圆括号，单独使用圆括号会产生一个子shell(xyz=123),父shell是无法看到这个变量的；数组的初始化IPS=(ip1 ip2 ip3)；执行命令cmd1=$(ls)
     [],[[]] 方括号，单独使用方括号是测试(test)或数组元素功能，两个方括号表示测试表达式，可以使用>,<[[ 5 > 4 ]]
     <> 尖括号，重定向符号，2> 错误重定向
     {} 花括号，输出范围：echo {0..9}，输出0到9，用在for循环；文件复制：cp -v /etc/passwd{,.bak}（-v复制期间详细输出）《=》 cp /etc/passwd /etc/passwd.bak
     注意：let简写为(())，test简写为[]
     $(ls)用来获取执行命令后的值，``也是用来执行命令的
运算和逻辑符号：加减乘除 && || !
转义符号：
其他符号：#注释符
        ;命令分隔符
        case语句的分隔符要转义;;
        :空指令，占位符
        . 和source命令相同
        ~家目录
        ,分割目录
        *通配符 ls * ; ls ?.sh
        ?条件测试或通配符，只能匹配一个字符
        $取值符号
        |管道符
        &后台运行
         空格
===========================================================
测试和判断(0为True，非0为False)
退出程序命令：exit 10 返回10给 shell，返回值非0 为不正常退出
           $? 判断当前shell前一个命令是否正常退出
test命令用于检测文件或比较值：文件测试
                         整数比较测试
                         字符串测试
test测试语句可以简化为[]符号，[]符号还有扩展写法[[]]支持&&、||、<、>
===========================================================
if语句
if [ $USER = "root" ];then
        echo "please run"
        if [ -x /root/shellscript2/2.sh ];then
                /root/shellscript2/2.sh
        fi
else
        echo "switch user root"
fi
===========================================================
case语句和select语句可以构成分支
case $1 in
        "start"|"START")
                echo $0 "start...."
        ;;
        "stop")
                echo $0 "stop...."
        ;;
        "restart"|"reload")
                echo $0 "restart...."
        ;;
        *)
                echo "Usage:$0 {start|stop|restart|reload}"
        ;;
esac
==============================================================
for i in {1..9}
do
    echo $i
done

for i in `ls *.map3.ma4.mp4`; do mv ./$i $(basename $i .map3.ma4.mp4).mp4; done
==============================================================
awk中会使用到
for ((i=1;i<=10;i++))
do
    echo $i
done
==============================================================
while test测试是否成立
do
    命令
done

a=1
while [ $a -lt 10 ]; do  echo $a;  a=$(expr $a + 1); done
until循环和while循环相反，循环测试为假时，执行循环，为真时循环停止
================================================================